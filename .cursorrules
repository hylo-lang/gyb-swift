We are working on a translation of the Python `gyb.py` tool to Swift.  The original tool is at https://raw.githubusercontent.com/swiftlang/swift/refs/heads/main/utils/gyb.py

Follow the Swift API guidelines https://www.swift.org/documentation/api-design-guidelines/
Uphold the principles outlined in https://github.com/stlab/better-code/blob/main/better-code/src/chapter-2-contracts.md

If they conflict, give priority to the contracts chapter.

Whenever you are given corrections to general methodology, update the .cursorrules file with that information.

Never decide that something can be skipped, non-functional, stubbed, or not tested without checking with the human operator first.

Use swift-format to keep the source formatted.  Limit line lengths in
code, including comments, to 100 characters.

To save time, instead of doing separate consecutive `swift build` and `swift test` commands, just use `swift test` which will always build first if necessary.

In tests, do not do parial checks of results (like `result.contains(y)`) when you could check the entire value of `result`.

When running tests added temporarily for diagnostic purposes, run `swift test --filter <testname>` to avoid running other tests or being confused by their output.

Do not use any arbitrary thresholds or heuristics in the actual code.

Always use structs instead of classes where possible.

Avoid needless nesting.

Every comment in the body of a function of the form "now we're going to X" indicates the next section of code should be its own function with a meaningful name.

Each time you write a block of code with a preceding explanatory comment, extract it into a separate well-named function where the explanation becomes the function's contract. Apply this principle everywhere ongoingly.

Avoid raw loops and use algorithms instead where possible.

Always fix all warnings.

Avoid conditional compilation as it makes code that runs on other platforms impossible to typecheck.  Set global constants to identify platforms and use runtime branches.

Never swallow errors. When a function can fail, use `throws` to propagate descriptive errors rather than returning optionals or silently failing. This ensures failures are visible and debuggable.

When system APIs or external processes throw errors, wrap them in `Failure` with contextual information about what operation was being performed. This makes errors easier to diagnose, especially on different platforms. For example, wrap file I/O errors with the path being accessed, and process execution errors with the command being run.

When invoking `swiftc`, pass `-module-cache-path` with a temporary directory to avoid conflicts when running in parallel (e.g., during `swift test`).

## Naming Guidelines

Avoid putting type information in non-type names. Variable names should reflect the role of the value, if at all possible. If you can't find a better name for a variable than one that reflects its type, use a single letter name.

Extension property and method names must be clear about what they return. Use gerunds (verbs ending in -ing) for transformations (e.g., `normalizingLineEndings()` not `normalizedLineEndings`).

Avoid computed properties that aren't O(1). Any operation that scans or transforms the entire collection should be a method, not a property.

Only use intermediate variables where they reduce nesting or significantly reduce code size. Variables used only once should be avoided.

## Documentation Guidelines

- Every declaration outside a function body needs a doc comment except for tests and declarations that satisfy protocol requirements.
- Capture the complete contract in concise summaries following better-code contracts principles
- Avoid verbose parameter blocks when good naming and a clear summary suffice
- Name parameters in summary (e.g., "`nodes`'s text") to show their roles precisely
- Use `self` rather than "this T" where T is the type of `self` (e.g., "`self` decoded as UTF-8" not "This data decoded as UTF-8")
- Raise the level of abstraction - focus on semantic meaning rather than implementation details
- Doc comments describe the contract (what, not how). Implementation details and rationale belong in regular comments inside the function body.
- When multiple sentences are needed, separate them with a blank line
- Prefer single sentences with clauses (e.g., ", or `nil` if...") over multiple short sentences
- Document init functions as though they are descriptions of the
  constructed object, e.g. `A sequence of tokens from a template`.
- Document subscripts like properties, i.e. "The element at position `i`."
